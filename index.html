<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>TAE TETRIS</title>
<style>
html, body {
  margin:0; padding:0;
  height:100%; width:100%;
  overflow:hidden; background:#111;
  font-family:sans-serif;
  touch-action: manipulation;
}
#container {
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:flex-start;
  height:100%;
  width:100%;
  padding-top:20px;
}
#scoreboard { color:white; font-size:24px; margin-bottom:5px; text-align:center;}
#instructions { color:#aaa; font-size:16px; margin-bottom:5px; text-align:center;}
#credit { color:#777; font-size:14px; margin-bottom:10px; text-align:center;}
#game {
  display:grid;
  gap:1px;
  background:#222;
}
.cell { background:#111; }
.controls {
  display:flex; justify-content:center; gap:10px; margin-top:10px;
}
.btn {
  width:70px; height:70px;
  background:rgba(255,255,255,0.2);
  display:flex; align-items:center; justify-content:center;
  font-size:32px; border-radius:10px; user-select:none;
}
</style>
</head>
<body>
<div id="container">
  <div id="scoreboard">Score: <span id="score">0</span></div>
  <div id="instructions">Swipe or use buttons to move & rotate. Fill lines to score!</div>
  <div id="credit">Made by @nortydigitalcrew</div>
  <div id="game"></div>
  <div class="controls">
    <div id="left" class="btn">◀</div>
    <div id="rotate" class="btn">⟳</div>
    <div id="right" class="btn">▶</div>
    <div id="down" class="btn">▼</div>
  </div>
</div>

<script>
const rows = 20;
const cols = 10;
const game = document.getElementById('game');
const scoreEl = document.getElementById('score');
let score = 0;

// Calculate cell size for proper 9:16 layout
const gameWidth = Math.min(window.innerWidth*0.9, 400);
const cellSize = Math.floor(gameWidth / cols);

game.style.width = `${cellSize*cols}px`;
game.style.height = `${cellSize*rows}px`;
game.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
game.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;

// Grid creation
let grid = [];
for(let r=0;r<rows;r++){
  let row=[];
  for(let c=0;c<cols;c++){
    const cell = document.createElement('div');
    cell.className='cell';
    cell.style.width = `${cellSize}px`;
    cell.style.height = `${cellSize}px`;
    game.appendChild(cell);
    row.push(cell);
  }
  grid.push(row);
}

// Pieces
const colors = ['cyan','blue','orange','yellow','green','purple','red'];
const pieces = [
  [[1,1,1,1]], // I
  [[1,0,0],[1,1,1]], // J
  [[0,0,1],[1,1,1]], // L
  [[1,1],[1,1]], // O
  [[0,1,1],[1,1,0]], // S
  [[0,1,0],[1,1,1]], // T
  [[1,1,0],[0,1,1]]  // Z
];

let currentPiece = null;
let posX=0,posY=0;
let fallSpeed=500;
let dropInterval;

// Spawn piece
function newPiece(){
  const p = pieces[Math.floor(Math.random()*pieces.length)];
  const color = colors[Math.floor(Math.random()*colors.length)];
  currentPiece={shape:p,color:color};
  posX=Math.floor(cols/2)-Math.floor(p[0].length/2);
  posY=0;
}

// Draw function
function draw(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      grid[r][c].style.background=grid[r][c].dataset.color||'#111';
    }
  }
  if(!currentPiece) return;
  currentPiece.shape.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val && grid[posY+y] && grid[posY+y][posX+x]) grid[posY+y][posX+x].style.background=currentPiece.color;
    });
  });
}

// Collision detection
function collides(dx=0,dy=0,newShape=null){
  const shape = newShape || currentPiece.shape;
  for(let y=0;y<shape.length;y++){
    for(let x=0;x<shape[y].length;x++){
      if(shape[y][x]){
        let nx=posX+x+dx;
        let ny=posY+y+dy;
        if(nx<0||nx>=cols||ny>=rows) return true;
        if(grid[ny][nx].dataset.color) return true;
      }
    }
  }
  return false;
}

// Freeze piece
function freeze(){
  currentPiece.shape.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val) grid[posY+y][posX+x].dataset.color=currentPiece.color;
    });
  });
}

// Clear lines
function clearLines(){
  for(let y=rows-1;y>=0;y--){
    if(grid[y].every(cell=>cell.dataset.color)){
      score += 10;
      scoreEl.textContent = score;
      for(let ty=y; ty>0; ty--){
        for(let x=0;x<cols;x++){
          grid[ty][x].dataset.color = grid[ty-1][x].dataset.color||'';
        }
      }
      y++;
      fallSpeed = Math.max(100,500-Math.floor(score/50)*50);
      clearInterval(dropInterval);
      dropInterval = setInterval(fall,fallSpeed);
    }
  }
}

// Rotate
function rotate(shape){
  return shape[0].map((_,i)=>shape.map(row=>row[i])).reverse();
}

// Controls
function moveLeft(){ if(!collides(-1,0)) posX--; draw();}
function moveRight(){ if(!collides(1,0)) posX++; draw();}
function moveDown(){ 
  if(!collides(0,1)){ 
    posY++; 
    score++; 
    scoreEl.textContent = score;
  } 
  else { freeze(); clearLines(); newPiece(); if(collides(0,0)){ alert('Game Over! Score: '+score); location.reload();} } 
  draw();
}
function rotatePiece(){ const rotated=rotate(currentPiece.shape); if(!collides(0,0,rotated)) currentPiece.shape=rotated; draw(); }

// Keyboard
document.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft') moveLeft();
  if(e.key==='ArrowRight') moveRight();
  if(e.key==='ArrowDown') moveDown();
  if(e.key==='ArrowUp') rotatePiece();
});

// Touch buttons
document.getElementById('left').addEventListener('touchstart', moveLeft);
document.getElementById('right').addEventListener('touchstart', moveRight);
document.getElementById('down').addEventListener('touchstart', moveDown);
document.getElementById('rotate').addEventListener('touchstart', rotatePiece);

// Swipe controls
let startX=0,startY=0;
document.addEventListener('touchstart', e=>{
  startX=e.touches[0].clientX;
  startY=e.touches[0].clientY;
});
document.addEventListener('touchend', e=>{
  const dx=e.changedTouches[0].clientX - startX;
  const dy=e.changedTouches[0].clientY - startY;
  if(Math.abs(dx) > Math.abs(dy)){
    if(dx>20) moveRight();
    else if(dx<-20) moveLeft();
  } else {
    if(dy>20) moveDown();
    else if(dy<-20) rotatePiece();
  }
});

// Game loop
function fall(){ moveDown(); }

newPiece();
draw();
dropInterval = setInterval(fall,fallSpeed);

</script>
</body>
</html>