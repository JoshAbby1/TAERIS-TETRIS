<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>TAE TETRIS</title>
<style>
body { margin:0; display:flex; justify-content:center; align-items:center; background:#111; color:white; font-family:sans-serif; overflow:hidden;}
#container { display:flex; flex-direction:column; align-items:center;}
#game { display:grid; gap:1px; background:#222;}
.cell { background:#111; width:100%; height:100%;}
#scoreboard { margin:10px; font-size:24px;}
.controls { display:flex; gap:10px; margin-top:10px;}
.btn { width:60px; height:60px; background:rgba(255,255,255,0.2); display:flex; justify-content:center; align-items:center; font-size:32px; border-radius:10px; user-select:none;}
</style>
</head>
<body>
<div id="container">
  <div id="scoreboard">Score: <span id="score">0</span></div>
  <div id="game"></div>
  <div class="controls">
    <div id="left" class="btn">◀</div>
    <div id="rotate" class="btn">⟳</div>
    <div id="right" class="btn">▶</div>
    <div id="down" class="btn">▼</div>
  </div>
</div>

<script>
const rows = 20;
const cols = 10;
const game = document.getElementById('game');
const scoreEl = document.getElementById('score');
let score=0;

// Responsive cell size for 9:16
const cellSize = Math.floor(window.innerHeight*0.9/rows); 
game.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
game.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;

// Create grid
let grid = [];
for(let r=0;r<rows;r++){
  let row=[];
  for(let c=0;c<cols;c++){
    const cell = document.createElement('div');
    cell.className='cell';
    game.appendChild(cell);
    row.push(cell);
  }
  grid.push(row);
}

// Pieces and colors
const colors = ['cyan','blue','orange','yellow','green','purple','red'];
const pieces = [
  [[1,1,1,1]], // I
  [[1,0,0],[1,1,1]], // J
  [[0,0,1],[1,1,1]], // L
  [[1,1],[1,1]], // O
  [[0,1,1],[1,1,0]], // S
  [[0,1,0],[1,1,1]], // T
  [[1,1,0],[0,1,1]]  // Z
];

// Current piece
let currentPiece=null;
let posX=0,posY=0;
let fallSpeed=500; // initial ms
let dropInterval;

// Spawn a piece
function newPiece(){
  const p = pieces[Math.floor(Math.random()*pieces.length)];
  const color = colors[Math.floor(Math.random()*colors.length)];
  currentPiece={shape:p,color:color};
  posX=Math.floor(cols/2)-Math.floor(p[0].length/2);
  posY=0;
}

// Draw
function draw(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(grid[r][c].dataset.color) grid[r][c].style.background=grid[r][c].dataset.color;
      else grid[r][c].style.background='#111';
    }
  }
  if(!currentPiece) return;
  currentPiece.shape.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val && grid[posY+y] && grid[posY+y][posX+x]) grid[posY+y][posX+x].style.background=currentPiece.color;
    });
  });
}

// Collision
function collides(dx=0,dy=0,newShape=null){
  const shape=newShape||currentPiece.shape;
  for(let y=0;y<shape.length;y++){
    for(let x=0;x<shape[y].length;x++){
      if(shape[y][x]){
        let nx=posX+x+dx;
        let ny=posY+y+dy;
        if(nx<0||nx>=cols||ny>=rows) return true;
        if(grid[ny][nx].dataset.color) return true;
      }
    }
  }
  return false;
}

// Freeze
function freeze(){
  currentPiece.shape.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val) grid[posY+y][posX+x].dataset.color=currentPiece.color;
    });
  });
}

// Clear lines
function clearLines(){
  for(let y=rows-1;y>=0;y--){
    if(grid[y].every(cell=>cell.dataset.color)){
      score+=10;
      scoreEl.textContent=score;
      for(let ty=y;ty>0;ty--){
        for(let x=0;x<cols;x++){
          grid[ty][x].dataset.color=grid[ty-1][x].dataset.color||'';
        }
      }
      y++;
      // increase speed as score rises
      fallSpeed = Math.max(100,500- Math.floor(score/50)*50);
      clearInterval(dropInterval);
      dropInterval = setInterval(fall, fallSpeed);
    }
  }
}

// Rotate
function rotate(shape){
  return shape[0].map((_,i)=>shape.map(row=>row[i])).reverse();
}

// Controls
function moveLeft(){ if(!collides(-1,0)) posX--; draw();}
function moveRight(){ if(!collides(1,0)) posX++; draw();}
function moveDown(){ if(!collides(0,1)) posY++; else {freeze(); clearLines(); newPiece(); if(collides(0,0)){ alert('Game Over! Score: '+score); location.reload();}} draw();}
function rotatePiece(){ const rotated=rotate(currentPiece.shape); if(!collides(0,0,rotated)) currentPiece.shape=rotated; draw(); }

document.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft') moveLeft();
  if(e.key==='ArrowRight') moveRight();
  if(e.key==='ArrowDown') moveDown();
  if(e.key==='ArrowUp') rotatePiece();
});

document.getElementById('left').addEventListener('touchstart', moveLeft);
document.getElementById('right').addEventListener('touchstart', moveRight);
document.getElementById('down').addEventListener('touchstart', moveDown);
document.getElementById('rotate').addEventListener('touchstart', rotatePiece);

// Game loop
function fall(){
  if(!collides(0,1)) posY++;
  else { freeze(); clearLines(); newPiece(); if(collides(0,0)){ alert('Game Over! Score: '+score); location.reload();} }
  draw();
}

newPiece();
draw();
dropInterval = setInterval(fall,fallSpeed);

</script>
</body>
</html>