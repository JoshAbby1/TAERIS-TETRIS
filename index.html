<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>TAE TETRIS</title>
<style>
html, body {
  margin:0; padding:0;
  height:100%; width:100%;
  overflow:hidden; background:#111;
  font-family:sans-serif;
  touch-action: manipulation; /* disables zoom on touch */
}
#container {
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  height:100%;
  width:100%;
}
#scoreboard { color:white; font-size:24px; margin-bottom:10px; }
#game {
  display:grid;
  gap:1px;
  background:#222;
}
.cell { background:#111; width:100%; height:100%; }
</style>
</head>
<body>
<div id="container">
  <div id="scoreboard">Score: <span id="score">0</span></div>
  <div id="game"></div>
</div>

<script>
const rows = 20;
const cols = 10;
const game = document.getElementById('game');
const scoreEl = document.getElementById('score');
let score=0;

// Responsive 9:16 cell sizing
const cellSize = Math.floor(window.innerHeight*0.9/rows);
game.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
game.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;

// Create grid
let grid = [];
for(let r=0;r<rows;r++){
  let row=[];
  for(let c=0;c<cols;c++){
    const cell = document.createElement('div');
    cell.className='cell';
    game.appendChild(cell);
    row.push(cell);
  }
  grid.push(row);
}

// Pieces and colors
const colors = ['cyan','blue','orange','yellow','green','purple','red'];
const pieces = [
  [[1,1,1,1]], // I
  [[1,0,0],[1,1,1]], // J
  [[0,0,1],[1,1,1]], // L
  [[1,1],[1,1]], // O
  [[0,1,1],[1,1,0]], // S
  [[0,1,0],[1,1,1]], // T
  [[1,1,0],[0,1,1]]  // Z
];

// Current piece
let currentPiece=null;
let posX=0,posY=0;
let fallSpeed=500;
let dropInterval;

// Spawn piece
function newPiece(){
  const p = pieces[Math.floor(Math.random()*pieces.length)];
  const color = colors[Math.floor(Math.random()*colors.length)];
  currentPiece={shape:p,color:color};
  posX=Math.floor(cols/2)-Math.floor(p[0].length/2);
  posY=0;
}

// Draw
function draw(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      grid[r][c].style.background=grid[r][c].dataset.color||'#111';
    }
  }
  if(!currentPiece) return;
  currentPiece.shape.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val && grid[posY+y] && grid[posY+y][posX+x]) grid[posY+y][posX+x].style.background=currentPiece.color;
    });
  });
}

// Collision
function collides(dx=0,dy=0,newShape=null){
  const shape = newShape || currentPiece.shape;
  for(let y=0;y<shape.length;y++){
    for(let x=0;x<shape[y].length;x++){
      if(shape[y][x]){
        let nx=posX+x+dx;
        let ny=posY+y+dy;
        if(nx<0 || nx>=cols || ny>=rows) return true;
        if(grid[ny][nx].dataset.color) return true;
      }
    }
  }
  return false;
}

// Freeze
function freeze(){
  currentPiece.shape.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val) grid[posY+y][posX+x].dataset.color=currentPiece.color;
    });
  });
}

// Clear lines
function clearLines(){
  for(let y=rows-1;y>=0;y--){
    if(grid[y].every(cell=>cell.dataset.color)){
      score += 10;
      scoreEl.textContent = score;
      for(let ty=y; ty>0; ty--){
        for(let x=0;x<cols;x++){
          grid[ty][x].dataset.color = grid[ty-1][x].dataset.color||'';
        }
      }
      y++;
      // increase speed as score rises
      fallSpeed = Math.max(100,500-Math.floor(score/50)*50);
      clearInterval(dropInterval);
      dropInterval = setInterval(fall, fallSpeed);
    }
  }
}

// Rotate
function rotate(shape){
  return shape[0].map((_,i)=>shape.map(row=>row[i])).reverse();
}

// Controls
function moveLeft(){ if(!collides(-1,0)) posX--; draw();}
function moveRight(){ if(!collides(1,0)) posX++; draw();}
function moveDown(){ if(!collides(0,1)) posY++; else {freeze(); clearLines(); newPiece(); if(collides(0,0)){ alert('Game Over! Score: '+score); location.reload();}} draw();}
function rotatePiece(){ const rotated=rotate(currentPiece.shape); if(!collides(0,0,rotated)) currentPiece.shape=rotated; draw(); }

// Keyboard
document.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft') moveLeft();
  if(e.key==='ArrowRight') moveRight();
  if(e.key==='ArrowDown') moveDown();
  if(e.key==='ArrowUp') rotatePiece();
});

// Swipe / touch controls
let startX=0,startY=0;
document.addEventListener('touchstart', e=>{
  startX=e.touches[0].clientX;
  startY=e.touches[0].clientY;
});

document.addEventListener('touchend', e=>{
  const dx=e.changedTouches[0].clientX - startX;
  const dy=e.changedTouches[0].clientY - startY;
  if(Math.abs(dx) > Math.abs(dy)){
    if(dx>20) moveRight();
    else if(dx<-20) moveLeft();
  } else {
    if(dy>20) moveDown();
    else if(dy<-20) rotatePiece();
  }
});

// Game loop
function fall(){
  if(!collides(0,1)) posY++;
  else { freeze(); clearLines(); newPiece(); if(collides(0,0)){ alert('Game Over! Score: '+score); location.reload();} }
  draw();
}

newPiece();
draw();
dropInterval = setInterval(fall,fallSpeed);

</script>
</body>
</html>